"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.digestGuestTxHash = exports.digestTxHash = exports.toTransactions = exports.toTransaction = exports.isUnipassWalletTransaction = exports.transactionFromJsonObj = exports.transactionToJson = exports.CallType = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("@unipasswallet/utils");
const utils_2 = require("ethers/lib/utils");
var CallType;
(function (CallType) {
    CallType[CallType["Call"] = 0] = "Call";
    CallType[CallType["DelegateCall"] = 1] = "DelegateCall";
})(CallType = exports.CallType || (exports.CallType = {}));
function transactionToJson(tx) {
    return `{"_isUnipassWalletTransaction":true,"callType":${tx.callType},"revertOnError":${tx.revertOnError},"gasLimit":"${(0, utils_2.hexlify)(tx.gasLimit)}","target":"${(0, utils_2.hexlify)(tx.target)}","value":"${(0, utils_2.hexlify)(tx.value)}","data":"${(0, utils_2.hexlify)(tx.data)}"}`;
}
exports.transactionToJson = transactionToJson;
function transactionFromJsonObj(obj) {
    if (obj._isUnipassWalletTransaction !== true) {
        throw new Error("Expected _isUnipassWalletTransaction to be true");
    }
    return {
        _isUnipassWalletTransaction: true,
        callType: obj.callType,
        revertOnError: obj.revertOnError,
        gasLimit: ethers_1.BigNumber.from(obj.gasLimit),
        target: (0, utils_2.hexlify)(obj.target),
        value: ethers_1.BigNumber.from(obj.value),
        data: (0, utils_2.hexlify)(obj.data),
    };
}
exports.transactionFromJsonObj = transactionFromJsonObj;
function isUnipassWalletTransaction(v) {
    return v._isUnipassWalletTransaction;
}
exports.isUnipassWalletTransaction = isUnipassWalletTransaction;
function toTransaction(transaction) {
    if (isUnipassWalletTransaction(transaction)) {
        return transaction;
    }
    return {
        _isUnipassWalletTransaction: true,
        callType: CallType.Call,
        revertOnError: false,
        gasLimit: ethers_1.BigNumber.from(transaction.gasLimit),
        target: transaction.to,
        value: ethers_1.BigNumber.from(transaction.value),
        data: transaction.data,
    };
}
exports.toTransaction = toTransaction;
function toTransactions(transactions) {
    if (Array.isArray(transactions)) {
        return transactions.map((v) => toTransaction(v));
    }
    else {
        return [toTransaction(transactions)];
    }
}
exports.toTransactions = toTransactions;
function digestTxHash(chainId, walletAddr, nonce, transactions) {
    return (0, utils_1.subDigest)(chainId, walletAddr, (0, utils_2.keccak256)(utils_2.defaultAbiCoder.encode([
        "uint256",
        "tuple(uint8 callType,bool revertOnError,address target,uint256 gasLimit,uint256 value,bytes data)[]",
    ], [nonce, transactions])));
}
exports.digestTxHash = digestTxHash;
function digestGuestTxHash(chainId, moduleGuestAddress, transactions) {
    return (0, utils_1.subDigest)(chainId, moduleGuestAddress, (0, utils_2.keccak256)(utils_2.defaultAbiCoder.encode([
        "string",
        "tuple(uint8 callType,bool revertOnError,address target,uint256 gasLimit,uint256 value,bytes data)[]",
    ], ["guest:", transactions])));
}
exports.digestGuestTxHash = digestGuestTxHash;
//# sourceMappingURL=transaction.js.map