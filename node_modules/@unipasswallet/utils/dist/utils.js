"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.obscureEmail = exports.getByTransactionData = exports.resolveArrayProperties = exports.isContractDeployed = exports.getAddressDeployedBySingletonFactory = exports.getWalletAddress = exports.getWalletCode = exports.subDigest = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const constants_1 = require("./constants");
const abi_1 = require("@unipasswallet/abi");
function subDigest(chainId, address, hash) {
    return (0, utils_1.keccak256)((0, utils_1.solidityPack)(["bytes", "uint256", "address", "bytes32"], [(0, utils_1.toUtf8Bytes)("\x19\x01"), chainId, address, hash]));
}
exports.subDigest = subDigest;
function getWalletCode(moduleMainAddr) {
    return (0, utils_1.solidityPack)(["bytes", "uint256"], [constants_1.CreationCode, moduleMainAddr]);
}
exports.getWalletCode = getWalletCode;
function getWalletAddress(moduleMainAddr, keysetHash) {
    const code = getWalletCode(moduleMainAddr);
    return (0, utils_1.getCreate2Address)(constants_1.SingletonFactoryAddress, keysetHash, (0, utils_1.keccak256)(code));
}
exports.getWalletAddress = getWalletAddress;
function getAddressDeployedBySingletonFactory(salt, initCodeHash) {
    return (0, utils_1.getCreate2Address)(constants_1.SingletonFactoryAddress, salt, initCodeHash);
}
exports.getAddressDeployedBySingletonFactory = getAddressDeployedBySingletonFactory;
function isContractDeployed(addr, provider) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield provider.getCode(addr)) !== "0x";
    });
}
exports.isContractDeployed = isContractDeployed;
function resolveArrayProperties(object) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Array.isArray(object)) {
            // T must include array type
            return Promise.all(object.map((o) => (0, utils_1.resolveProperties)(o)));
        }
        return (0, utils_1.resolveProperties)(object);
    });
}
exports.resolveArrayProperties = resolveArrayProperties;
function getByTransactionData(walletAddr, data, provider) {
    return __awaiter(this, void 0, void 0, function* () {
        const contractInterface = new utils_1.Interface(abi_1.moduleMain.abi);
        const sigHash = contractInterface.getSighash(data);
        if (sigHash === contractInterface.getSighash("_selfExecute")) {
            const roleWeight = contractInterface.decodeFunctionData("_selfExecute", data);
            return [roleWeight.ownerWeight, roleWeight.assetsOpWeight, roleWeight.guardianWeight];
        }
        const wallet = new ethers_1.Contract(walletAddr, contractInterface, provider);
        const roleWeight = yield wallet.getRoleOfPermission(sigHash);
        return roleWeight.map((v) => v.toNumber());
    });
}
exports.getByTransactionData = getByTransactionData;
function obscureEmail(email) {
    if (!email) {
        return "";
    }
    const emailData = email.split("@");
    const emailStart = emailData[0][0];
    const emailEnd = emailData[0][emailData[0].length - 1];
    if (email.includes("@")) {
        return `${emailStart}***${emailEnd}@${emailData[1]}`;
    }
    return `${emailStart}***${emailEnd}`;
}
exports.obscureEmail = obscureEmail;
//# sourceMappingURL=utils.js.map