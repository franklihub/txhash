"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptKeystore = exports.encryptKeystore = void 0;
const aes_js_1 = __importDefault(require("aes-js"));
const scrypt_js_1 = __importDefault(require("scrypt-js"));
const utils_1 = require("ethers/lib/utils");
const pbkdf2_1 = require("@ethersproject/pbkdf2");
function encryptKeystore(input, password, options, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof options === "function" && !progressCallback) {
            // eslint-disable-next-line no-param-reassign
            progressCallback = options;
            // eslint-disable-next-line no-param-reassign
            options = {};
        }
        if (!options) {
            // eslint-disable-next-line no-param-reassign
            options = {};
        }
        const inputBytes = (0, utils_1.arrayify)(input);
        const passwordBytes = getPassword(password);
        // Check/generate the salt
        let salt = null;
        if (options.salt) {
            salt = (0, utils_1.arrayify)(options.salt);
        }
        else {
            salt = (0, utils_1.randomBytes)(32);
        }
        // Override initialization vector
        let iv = null;
        if (options.iv) {
            iv = (0, utils_1.arrayify)(options.iv);
            if (iv.length !== 16) {
                throw new Error("invalid iv");
            }
        }
        else {
            iv = (0, utils_1.randomBytes)(16);
        }
        // Override the uuid
        let uuidRandom = null;
        if (options.uuid) {
            uuidRandom = (0, utils_1.arrayify)(options.uuid);
            if (uuidRandom.length !== 16) {
                throw new Error("invalid uuid");
            }
        }
        else {
            uuidRandom = (0, utils_1.randomBytes)(16);
        }
        // Override the scrypt password-based key derivation function parameters
        // eslint-disable-next-line no-bitwise
        let N = 1 << 17, r = 8, p = 1;
        if (options.scrypt) {
            if (options.scrypt.N) {
                N = options.scrypt.N;
            }
            if (options.scrypt.r) {
                r = options.scrypt.r;
            }
            if (options.scrypt.p) {
                p = options.scrypt.p;
            }
        }
        // We take 64 bytes:
        //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
        //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
        return scrypt_js_1.default.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {
            // eslint-disable-next-line no-param-reassign
            key = (0, utils_1.arrayify)(key);
            // This will be used to encrypt the wallet (as per Web3 secret storage)
            const derivedKey = key.slice(0, 16);
            const macPrefix = key.slice(16, 32);
            // Encrypt the private key
            const counter = new aes_js_1.default.Counter(iv);
            // eslint-disable-next-line new-cap
            const aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);
            const ciphertext = (0, utils_1.arrayify)(aesCtr.encrypt(inputBytes));
            // Compute the message authentication code, used to check the password
            const mac = (0, utils_1.keccak256)((0, utils_1.concat)([macPrefix, ciphertext]));
            // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
            const data = {
                id: uuidV4(uuidRandom),
                version: 3,
                Crypto: {
                    cipher: "aes-128-ctr",
                    cipherparams: {
                        iv: (0, utils_1.hexlify)(iv).substring(2),
                    },
                    ciphertext: utils_1.base64.encode(ciphertext),
                    kdf: "scrypt",
                    kdfparams: {
                        salt: (0, utils_1.hexlify)(salt).substring(2),
                        n: N,
                        dklen: 32,
                        p,
                        r,
                    },
                    mac: mac.substring(2),
                },
            };
            return JSON.stringify(data);
        });
    });
}
exports.encryptKeystore = encryptKeystore;
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
    const passwordBytes = getPassword(password);
    const kdf = searchPath(data, "crypto/kdf");
    if (kdf && typeof kdf === "string") {
        const throwError = (name, value) => {
            throw new Error(`invalid key-derivation function parameters: ${name} ${value}`);
        };
        if (kdf.toLowerCase() === "scrypt") {
            const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
            const N = parseInt(searchPath(data, "crypto/kdfparams/n"), 10);
            const r = parseInt(searchPath(data, "crypto/kdfparams/r"), 10);
            const p = parseInt(searchPath(data, "crypto/kdfparams/p"), 10);
            // Check for all required parameters
            if (!N || !r || !p) {
                throwError("kdf", kdf);
            }
            // Make sure N is a power of 2
            // eslint-disable-next-line no-bitwise
            if ((N & (N - 1)) !== 0) {
                throwError("N", N);
            }
            const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"), 10);
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
        }
        if (kdf.toLowerCase() === "pbkdf2") {
            const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
            let prfFunc = null;
            const prf = searchPath(data, "crypto/kdfparams/prf");
            if (prf === "hmac-sha256") {
                prfFunc = "sha256";
            }
            else if (prf === "hmac-sha512") {
                prfFunc = "sha512";
            }
            else {
                throwError("prf", prf);
            }
            const count = parseInt(searchPath(data, "crypto/kdfparams/c"), 10);
            const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"), 10);
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
        }
    }
    throw new Error(`unsupported key-derivation function: kdf ${kdf}`);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
    return (0, utils_1.arrayify)((0, pbkdf2_1.pbkdf2)(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _decrypt(data, key, ciphertext) {
    const cipher = searchPath(data, "crypto/cipher");
    if (cipher === "aes-128-ctr") {
        const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
        const counter = new aes_js_1.default.Counter(iv);
        // eslint-disable-next-line new-cap
        const aesCtr = new aes_js_1.default.ModeOfOperation.ctr(key, counter);
        return (0, utils_1.arrayify)(aesCtr.decrypt(ciphertext));
    }
    return null;
}
function _getInput(data, key) {
    const ciphertext = utils_1.base64.decode(searchPath(data, "crypto/ciphertext"));
    const computedMAC = (0, utils_1.hexlify)((0, utils_1.keccak256)((0, utils_1.concat)([key.slice(16, 32), ciphertext]))).substring(2);
    if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
        throw new Error("invalid password");
    }
    const input = _decrypt(data, key.slice(0, 16), ciphertext);
    return (0, utils_1.hexlify)(input);
}
function decryptKeystore(json, password, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = JSON.parse(json);
        const key = yield _computeKdfKey(data, password, pbkdf2, scrypt_js_1.default.scrypt, progressCallback);
        return _getInput(data, key);
    });
}
exports.decryptKeystore = decryptKeystore;
function getPassword(password) {
    if (typeof password === "string") {
        return (0, utils_1.toUtf8Bytes)(password, utils_1.UnicodeNormalizationForm.NFKC);
    }
    return (0, utils_1.arrayify)(password);
}
// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
function uuidV4(randomBytes) {
    const bytes = (0, utils_1.arrayify)(randomBytes);
    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    // eslint-disable-next-line no-bitwise
    bytes[6] = (bytes[6] & 0x0f) | 0x40;
    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    // eslint-disable-next-line no-bitwise
    bytes[8] = (bytes[8] & 0x3f) | 0x80;
    const value = (0, utils_1.hexlify)(bytes);
    return [
        value.substring(2, 10),
        value.substring(10, 14),
        value.substring(14, 18),
        value.substring(18, 22),
        value.substring(22, 34),
    ].join("-");
}
function searchPath(object, path) {
    let currentChild = object;
    const comps = path.toLowerCase().split("/");
    for (let i = 0; i < comps.length; i++) {
        // Search for a child object with a case-insensitive matching key
        let matchingChild = null;
        // eslint-disable-next-line no-restricted-syntax
        for (const key in currentChild) {
            if (key.toLowerCase() === comps[i]) {
                matchingChild = currentChild[key];
                break;
            }
        }
        // Didn't find one. :'(
        if (matchingChild === null) {
            return null;
        }
        // Now check this child...
        currentChild = matchingChild;
    }
    return currentChild;
}
function looseArrayify(hexString) {
    if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
        // eslint-disable-next-line no-param-reassign
        hexString = `0x${hexString}`;
    }
    return (0, utils_1.arrayify)(hexString);
}
//# sourceMappingURL=keystore.js.map